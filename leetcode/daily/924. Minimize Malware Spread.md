# [924. Minimize Malware Spread](https://leetcode.cn/problems/minimize-malware-spread/description/?envType=daily-question&envId=2024-04-16)



## Problem Explanation
If some nodes compose a network. <font color="red">And if there initial infect node number infectCnt is greater than 1</font>. Whichever node be remove, all of the nodes will be infect in the end.

And if there is only 1 node is infect. When we remove this node. All of the network will be safe. The reduce node number is the network's node count.

So, We just to sort the initial nodes and bfs them to find the exactly one node was be infect network x. We should to compare the count return the maximum count. 


Assume the node number is n
### Time complex:
O(n ^ 2)
We will visit n node. And to traverse it's adjacent node.

### Space complex:
O(n)

## Code

### python
```python
class Solution:
    # 先排序从最小的开始枚举节点
    # 每个节点开始遍历我能走到的节点个数，统计初始被感染的个数 cnt
        # cnt == 1 那么可以减少的就是该连通图的节点数
        # cnt > 1 就删除无影响，减少数量为0
        # 比较每次的数量，更新减少的最大值的index
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # sorted(initial)
        initial.sort()
        # print(initial)
        self.allInfectNodes = set(initial)
        n = len(graph)
        visit = [False] * n
        maxCnt = 0
        maxIndex = initial[0]
        for node in initial:
            if visit[node]:
                continue
            tempCnt = self.bfs(graph, initial, visit, node)
            if tempCnt > maxCnt:
                maxIndex = node
                maxCnt = tempCnt
        return maxIndex


    
    def bfs(self, graph: List[List[int]], initial: List[int], visit: List[bool], node: int) -> int:
        queue = [node]
        cnt = 1
        infectCnt = 1
        visit[node] = True
        while (len(queue) > 0):
            now = queue.pop(0)
            for i, access in enumerate(graph[now]):
                if access == 1 and not visit[i]:
                    cnt += 1
                    infectCnt += 1 if i in self.allInfectNodes else 0
                    visit[i] = True
                    queue.append(i)
        cnt = 0 if infectCnt > 1 else cnt
        # print("node: %d, index: %d" % (node, cnt))
        return cnt


```

### TypeScript
```TypeScript
function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    let visit: boolean[] = new Array<boolean>(n).fill(false);
    initial = initial.sort((a, b) => Number(a) - Number(b));
    // console.log(initial);
    let set = new Set(initial);
    let ans = -1;
    let maxCnt = -1;
    for (let node of initial) {
        if (visit[node] === true) continue;
        let cnt = bfs(visit, graph, node, set);
        if (cnt > maxCnt) {
            maxCnt = cnt;
            ans = node;
        }
    }
    return ans;
};

function bfs(visit: boolean[], graph: number[][], node: number, set: Set<number>): number {
    let cnt = 1;
    let infectCnt = 1;
    let queue = [node];
    visit[node] = true;
    while (queue.length > 0) {
        let now = queue.shift();
        for (let i = 0; i < graph[now].length; i++) {
            if (!visit[i] && graph[now][i] === 1) {
                queue.push(i);
                visit[i] = true;
                cnt++;
                infectCnt += set.has(i) ? 1 : 0;
            }
        }
    }
    // console.log(node + "," + cnt+","+infectCnt);
    return infectCnt > 1 ? 0 : cnt;
}


```