# [928. Minimize Malware Spread II](https://leetcode.cn/problems/minimize-malware-spread-ii/description/?envType=daily-question&envId=2024-04-17)



## Problem Explanation
We enumerate the remove node x. And to bfs this initial infected node. In the bfs we will not enter x. Then we can get the fianlly infected nodes.

Then we compare the count to return the answer.




Assume initial.length = m, graph.length = n
### Time complex:
O(n^2 * m + nlogn)
sort nlogn
enumerate initial m
bfs n^2
### Space complex:
O(n)
queue n
visit n


## Code

### python
```python
    # initial 排序然后枚举删除每个点i
    # 对于initial除了i 全部走一遍 bfs 得到cnt。最后选一个最小的
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial.sort()
        n = len(graph)
        minCnt = n
        ans = -1
        for node in initial:
            nowCnt = self.bfs(graph, initial, node)
            # print(node, nowCnt, minCnt, "===========")
            if (nowCnt < minCnt):
                minCnt = nowCnt
                ans = node
        return ans
    
    def bfs(self, graph: List[List[int]], initial: List[int], removeNode: int) -> int:
        queue = [node for node in initial if node != removeNode]
        # print(queue)
        n = len(graph)

        visit = [False] * n
        # 不会走到removeNode
        visit[removeNode] = True
        for node in queue:
            visit[node] = True
        
        infectCnt = len(queue)
        while (len(queue) > 0):
            nowNode = queue.pop(0)
            # print(graph[nowNode])
            for nextNode, val in enumerate(graph[nowNode]):
                # print(nextNode, not visit[nextNode])
                if not visit[nextNode] and val == 1:
                    visit[nextNode] = True
                    queue.append(nextNode)
                    infectCnt += 1
        return infectCnt
```

### TypeScript
```TypeScript
function minMalwareSpread(graph: number[][], initial: number[]): number {
    initial.sort((a, b) => Number(a) - Number(b));
    let minCnt = graph.length;;
    let ans = -1;
    for (let node of initial) {
        let nowCnt = bfs(graph, initial, node);
        if (minCnt > nowCnt) {
            minCnt = nowCnt;
            ans = node
        }
    }
    return ans;
};

function bfs(graph: number[][], initial: number[], removeNode: number): number {
    let visit: boolean[] = new Array<boolean>(graph.length).fill(false);
    visit[removeNode] = true;
    let queue: number[] = [];
    for (let i of initial) {
        if (i != removeNode) {
            queue.push(i);
            visit[i] = true;
        }
    }
    let cnt = queue.length;
    while (queue.length > 0) {
        let now = queue.shift();
        for (let i = 0; i < graph.length; i++) {
            if (!visit[i] && graph[now][i] == 1) {
                queue.push(i);
                visit[i] = true;
                cnt++;
            }
        }
    }
    return cnt;
}

```